{"version":3,"sources":["wx-touch-event.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * Created by zhengqiguang on 2017/4/30.\n */\n\n\nclass WxTouchEvent {\n    constructor() {\n        this.preV = {x: null, y: null};\n        this.pinchStartLen = null;\n        this.scale = 1;\n        this.isDoubleTap = false;\n    }\n\n    bind(option) {\n        this.element = null;\n\n        this.rotate = wrapFunc(this.element, option.rotate || noop);\n        this.touchStart = wrapFunc(this.element, option.touchStart || noop);\n        this.multipointStart = wrapFunc(this.element, option.multipointStart || noop);\n        this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop);\n        this.pinch = wrapFunc(this.element, option.pinch || noop);\n        this.swipe = wrapFunc(this.element, option.swipe || noop);\n        this.tap = wrapFunc(this.element, option.tap || noop);\n        this.doubleTap = wrapFunc(this.element, option.doubleTap || noop);\n        this.longTap = wrapFunc(this.element, option.longTap || noop);\n        this.singleTap = wrapFunc(this.element, option.singleTap || noop);\n        this.pressMove = wrapFunc(this.element, option.pressMove || noop);\n        this.touchMove = wrapFunc(this.element, option.touchMove || noop);\n        this.touchEnd = wrapFunc(this.element, option.touchEnd || noop);\n        this.touchCancel = wrapFunc(this.element, option.touchCancel || noop);\n\n        this.delta = null;\n        this.last = null;\n        this.now = null;\n        this.tapTimeout = null;\n        this.singleTapTimeout = null;\n        this.longTapTimeout = null;\n        this.swipeTimeout = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n        this.preTapPosition = {x: null, y: null};\n    }\n\n    start(evt) {\n        if (!evt.touches) return;\n        this.now = Date.now();\n        this.x1 = evt.touches[0].pageX;\n        this.y1 = evt.touches[0].pageY;\n        this.delta = this.now - (this.last || this.now);\n        this.touchStart.dispatch(evt);\n        if (this.preTapPosition.x !== null) {\n            this.isDoubleTap = (this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30);\n        }\n        this.preTapPosition.x = this.x1;\n        this.preTapPosition.y = this.y1;\n        this.last = this.now;\n        let preV = this.preV,\n            len = evt.touches.length;\n        if (len > 1) {\n            this._cancelLongTap();\n            this._cancelSingleTap();\n            let v = {x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1};\n            preV.x = v.x;\n            preV.y = v.y;\n            this.pinchStartLen = getLen(preV);\n            this.multipointStart.dispatch(evt);\n        }\n        this.longTapTimeout = setTimeout(function () {\n            evt.type = \"longTap\";\n            this.longTap.dispatch(evt);\n        }.bind(this), 750);\n    }\n\n    move(evt) {\n        if (!evt.touches) return;\n        let preV = this.preV,\n            len = evt.touches.length,\n            currentX = evt.touches[0].pageX,\n            currentY = evt.touches[0].pageY;\n        this.isDoubleTap = false;\n        if (len > 1) {\n            let v = {x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY};\n\n            if (preV.x !== null) {\n                if (this.pinchStartLen > 0) {\n                    evt.scale = getLen(v) / this.pinchStartLen;\n                    evt.type = \"pinch\";\n                    this.pinch.dispatch(evt);\n                }\n\n                evt.angle = getRotateAngle(v, preV);\n                evt.type = \"rotate\";\n                this.rotate.dispatch(evt);\n            }\n            preV.x = v.x;\n            preV.y = v.y;\n        } else {\n            if (this.x2 !== null) {\n                evt.deltaX = currentX - this.x2;\n                evt.deltaY = currentY - this.y2;\n\n            } else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this.pressMove.dispatch(evt);\n        }\n\n        this.touchMove.dispatch(evt);\n\n        this._cancelLongTap();\n        this.x2 = currentX;\n        this.y2 = currentY;\n        if (len > 1) {\n            // evt.preventDefault();\n        }\n    }\n\n    end(evt) {\n        if (!evt.changedTouches) return;\n        this._cancelLongTap();\n        let self = this;\n        if (evt.touches.length < 2) {\n            this.multipointEnd.dispatch(evt);\n        }\n        this.touchEnd.dispatch(evt);\n        //swipe\n        if ((this.x2 && Math.abs(this.x1 - this.x2) > 30) ||\n            (this.y2 && Math.abs(this.y1 - this.y2) > 30)) {\n            evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);\n            this.swipeTimeout = setTimeout(function () {\n                evt.type = \"swipe\";\n                self.swipe.dispatch(evt);\n\n            }, 0)\n        } else {\n            this.tapTimeout = setTimeout(function () {\n                console.info(\"tap\");\n                evt.type = \"tap\";\n                self.tap.dispatch(evt);\n                // trigger double tap immediately\n                if (self.isDoubleTap) {\n                    evt.type = \"doubleTap\";\n                    self.doubleTap.dispatch(evt);\n                    clearTimeout(self.singleTapTimeout);\n                    self.isDoubleTap = false;\n                }\n            }, 0)\n\n            if (!self.isDoubleTap) {\n                self.singleTapTimeout = setTimeout(function () {\n                    self.singleTap.dispatch(evt);\n                }, 250);\n            }\n        }\n\n        this.preV.x = 0;\n        this.preV.y = 0;\n        this.scale = 1;\n        this.pinchStartLen = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n    }\n\n    cancel(evt) {\n        clearTimeout(this.singleTapTimeout);\n        clearTimeout(this.tapTimeout);\n        clearTimeout(this.longTapTimeout);\n        clearTimeout(this.swipeTimeout);\n        this.touchCancel.dispatch(evt);\n    }\n\n\n    _cancelLongTap() {\n        clearTimeout(this.longTapTimeout);\n    }\n\n    _cancelSingleTap() {\n        clearTimeout(this.singleTapTimeout);\n    }\n\n    _swipeDirection(x1, x2, y1, y2) {\n        return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')\n    }\n\n    on(evt, handler) {\n        if (this[evt]) {\n            this[evt].add(handler);\n        }\n    }\n\n    off(evt, handler) {\n        if (this[evt]) {\n            this[evt].del(handler);\n        }\n    }\n\n    destroy() {\n        if (this.singleTapTimeout) clearTimeout(this.singleTapTimeout);\n        if (this.tapTimeout) clearTimeout(this.tapTimeout);\n        if (this.longTapTimeout) clearTimeout(this.longTapTimeout);\n        if (this.swipeTimeout) clearTimeout(this.swipeTimeout);\n\n        this.element.removeEventListener(\"touchstart\", this.start);\n        this.element.removeEventListener(\"touchmove\", this.move);\n        this.element.removeEventListener(\"touchend\", this.end);\n        this.element.removeEventListener(\"touchcancel\", this.cancel);\n\n        this.rotate.del();\n        this.touchStart.del();\n        this.multipointStart.del();\n        this.multipointEnd.del();\n        this.pinch.del();\n        this.swipe.del();\n        this.tap.del();\n        this.doubleTap.del();\n        this.longTap.del();\n        this.singleTap.del();\n        this.pressMove.del();\n        this.touchMove.del();\n        this.touchEnd.del();\n        this.touchCancel.del();\n\n        this.preV = this.pinchStartLen = this.scale = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = null;\n\n        return null;\n    }\n\n}\n\nlet noop = function () {\n};\n\nfunction getLen(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\nfunction dot(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\nfunction getAngle(v1, v2) {\n    let mr = getLen(v1) * getLen(v2);\n    if (mr === 0) return 0;\n    let r = dot(v1, v2) / mr;\n    if (r > 1) r = 1;\n    return Math.acos(r);\n}\n\nfunction cross(v1, v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nfunction getRotateAngle(v1, v2) {\n    let angle = getAngle(v1, v2);\n    if (cross(v1, v2) > 0) {\n        angle *= -1;\n    }\n\n    return angle * 180 / Math.PI;\n}\n\nlet HandlerAdmin = function (el) {\n    this.handlers = [];\n    this.el = el;\n};\n\nHandlerAdmin.prototype.add = function (handler) {\n    this.handlers.push(handler);\n}\n\nHandlerAdmin.prototype.del = function (handler) {\n    if (!handler) this.handlers = [];\n\n    for (let i = this.handlers.length; i >= 0; i--) {\n        if (this.handlers[i] === handler) {\n            this.handlers.splice(i, 1);\n        }\n    }\n}\n\nHandlerAdmin.prototype.dispatch = function () {\n    for (let i = 0, len = this.handlers.length; i < len; i++) {\n        let handler = this.handlers[i];\n        if (typeof handler === 'function') handler.apply(this.el, arguments);\n    }\n}\n\nfunction wrapFunc(el, handler) {\n    let handlerAdmin = new HandlerAdmin(el);\n    handlerAdmin.add(handler);\n\n    return handlerAdmin;\n}\n\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = WxTouchEvent;\n\n"]}